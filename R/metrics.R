bounce_rate_internal <- function(x, places){
  return(round(
    (
      length(x[!x %in% x[duplicated(x)]]) / length(x)
    ) * 100,
    digits = places
  ))
}

#'@title calculate the bounce rate within a session dataset
#'@description calculates the "bounce rate" within a set of sessions - the proportion of sessions
#'consisting only of a single event.
#'
#'@param sessions a sessions dataset, presumably generated with
#'\code{\link{sessionise}}.
#'
#'@param decimal_places the number of decimal places to round the output to
#'- set to 2 by default.
#'
#'@param user_id a column that contains unique user IDs. NULL by default; if set, the assumption
#'will be that you want \emph{per-user} bounce rates.
#'
#'@return either a single numeric value, representing the percentage of sessions
#'\emph{overall} that are bounces, or a data.frame of user IDs and bounce rates if
#'\code{user_id} is set to a column rather than NULL.
#'
#'@seealso \code{\link{session_events}} for generaliseable event-level calculations, and
#'\code{link{event_time}} for performing operations on the time between events.
#'
#'@examples
#'#Load and sessionise the dataset
#'data("session_dataset")
#'sessions <- sessionise(session_dataset, timestamp, uuid)
#'
#'# Calculate overall bounce rate
#'rate <- bounce_rate(sessions)
#'
#'# Calculate bounce rate on a per-user basis
#'per_user <- bounce_rate(sessions, user_id = uuid)
#'@export
bounce_rate <- function(sessions, decimal_places = 2, user_id = NULL){
  
  if(is.null(user_id)){
    return(bounce_rate_internal(sessions$session_id, decimal_places))
  }
  
  user_id <- as.character(substitute(user_id))
  
  split_data <- split(x = sessions$session_id, f = sessions[,user_id])
  to_output <- lapply(split_data, bounce_rate_internal, places = decimal_places)
  return(data.frame(user_id = names(to_output),
                    bounce_rate = unlist(to_output),
                    stringsAsFactors = FALSE))
}

time_on_page_internal <- function(x, func, precision){
  return(round(func(x, na.rm = TRUE), digits = precision))
}

time_on_page <- function(sessions, precision = 2, user_id = NULL, median = FALSE){
  
  if(median){
    func <- stats::median
  } else {
    func <- mean
  }
  
  if(is.null(user_id)){
    return(time_on_page_internal(sessions$time_delta, func, precision))
  }
  
  split_data <- split(x = sessions$time_delta, f = sessions[,user_id])
  to_output <- lapply(split_data, time_on_page_internal, func, precision)
  return(data.frame(user_id = names(to_output),
                    time_on_page = unlist(to_output),
                    stringsAsFactors = FALSE))
}

session_length_internal <- function(x){
  #ave?
}
session_length <- function(sessions, user_id = NULL){
  
}

session_count_internal <- function(x){
  return(length(unique(x)))
}

#' @title Count the number of sessions in a sessionised dataset
#' \code{link{session_count}} counts the number of sessions in a sessionised
#' dataset, producing either a count for the overall dataset or on a per-user
#' basis (see below).
#' 
#' @param sessions a dataset of sessions, presumably generated by
#' \code{\link{sessionise}}
#' 
#' @param user_id the column of \code{sessions} containing user IDs. If
#' NULL (the default), a single count of sessions for the entire dataset
#' will be generated. Otherwise, a data.frame of user IDs and the session
#' count for each user ID will be returned.
#' 
#' @return either a single integer value or a data.frame (see above).
#' 
#' @examples
#' #Load and sessionise the dataset
#' data("session_dataset")
#' sessions <- sessionise(session_dataset, timestamp, uuid)
#' 
#' # Calculate overall bounce rate
#' count <- session_count(sessions)
#' 
#' # Calculate bounce rate on a per-user basis
#' per_user <- session_count(sessions, user_id = uuid)
session_count <- function(sessions, user_id = NULL){
  
  if(is.null(user_id)){
    return(session_count_internal(sessions$session_id))
  }
  
  user_id <- as.character(substitute(user_id))
  
  split_data <- split(x = sessions$session_id, f = sessions[,user_id])
  to_output <- lapply(split_data, session_count_internal)
  return(data.frame(user_id = names(to_output),
                    session_count = unlist(to_output),
                    stringsAsFactors = FALSE))
}